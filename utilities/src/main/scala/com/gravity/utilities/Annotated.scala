package com.gravity.utilities

import com.gravity.utilities.components.FailureResult
import com.gravity.utilities.grvannotation.BasicNoteTypes
import com.gravity.utilities.grvevent._
import org.joda.time.DateTime

import scala.collection._
import scala.reflect.ClassTag
import scalaz.{NonEmptyList, Traverse, Validation}

/**
 * Created by runger on 3/14/14.
 */

object grvannotation extends grvannotation {

  object BasicNoteTypes {

    /**
     * A helper when defining a new stage.
     * Your makeNote method can be like so: new MsgNote(message) with StageNote
     */
    case class MsgNote[T](message: String) extends BasicMessageNote //The existence of an implementation here pushes us towards an inheritance model instead of a path-dependent type model.

    /**
     * A container for your StageMeta type. You will also want to define a case class for MetaType with Optional values for whatever meta data you want to stash.
     * case class StageMeta(name: Option[String] = None, context: Option[(URL, Timestamp)])
     * @param message The text that accompanies your Meta data when rendering via [[com.gravity.utilities.grvstage.Pipeline]]
     * @param meta an instance of the Stage's MetaType
     * @param canContinue a boolean indicating whether this is a critical value whose bad state cannot be recovered from
     * @Ntparam T the type of MetaType. (MetaType <: Product) means that MetaType is a case class.
     */
    class SimpleMessageMetaNote[MetaType <: Product](val message: String, val meta: MetaType, val canContinue: Boolean) extends BasicMessageMetaNote[MetaType] {
      def canContinueString: String = if(canContinue) "" else ", cannot continue"
      override def toString = s"MetaNote($message, ${meta.toString.take(200)}, $canContinueString)"
    }

    /**
     * Annotated enforces that all Notes must extend this trait
     */
    trait Note {
      val created: DateTime = grvtime.currentTime
    }

    trait BasicMessageNote extends Note {
      def message: String
    }

    trait BasicMetaNote[MetaType <: Product] {
      def meta: MetaType
      def canContinue: Boolean
    }

    trait BasicMessageMetaNote[T <: Product] extends BasicMetaNote[T] with BasicMessageNote
  }
}

trait grvannotation {
  import grvannotation.BasicNoteTypes._
  import grvstage._

  object Annotated {
    def apply[V](value: V): Annotated[V] = Annotated(value, Seq.empty)
    def apply[V](value: V, note: Note): Annotated[V] = Annotated(value, Seq(note))
  }

  /**
   * Annotated is useful for collecting meta data during a multi-stage transformation. 
   * @param value The value at the current stage of the transformation. Monadic operations refer to this field only, not to notes.
   * @param notes The notes that have accumulated up through this stage of the transformation.
   * @tparam V The type of the value
   */
  case class Annotated[+V](value: V, notes: Seq[Note] = Seq.empty) {

    /**
     * @param note A new note to add to the seq of notes
     * @return This value with a new note added to the seq
     */
    def annotate(note: Note): Annotated[V] = Annotated(value, notes :+ note)
    def annotate[N](canBeNote: N)(implicit noteMaker: CanBeNote[N]): Annotated[V] = Annotated(value, notes :+ noteMaker.toNote(canBeNote))

    /**
     * Transform the value using the function f, adding no new notes during the process.
     * @param f The transformation function
     * @tparam T The type returned by f
     * @return An Annotated with the a new value of type T, with the same notes as given
     */
    def map[T](f: V => T): Annotated[T] = {
      Annotated(f(value), notes)
    }


    /**
     * Transform the value using the function f, adding the notes from the Annotated instance generated during f.
     * @param f The transformation function
     * @tparam T The type returned by f
     * @return An Annotated with the a new value of type T, with any notes generated by f
     */
    def flatMap[T](f: V => Annotated[T]): Annotated[T] = {
      val newAnnot = f(value)
      Annotated(newAnnot.value, notes ++ newAnnot.notes)
    }

    /**
     * Split the annotated into its value and notes components. Useful when refactoring because you can leave the structure of code
     * similar to how you found it
     * val (value, notes) = annotatedMethod(param).tuple
     * @return A tuple of the value and notes
     */
    def tuple: (V, scala.Seq[Note]) = (value, notes)

    /**
     * Collect any notes matching the given partial function and transform them accordingly
     * @param pf 
     * @tparam N
     * @return
     */
    def collect[N](pf: PartialFunction[Note, N]): scala.Seq[N] = notes.collect(pf)

//    def fold(f: Annotated[V] => Unit): V = {
//      f(this)
//      value
//    }

    def drainTo(buffer: NoteBuffer): V = {
      buffer.addNotes(notes)
      value
    }

    def drainTo(buffer: mutable.Buffer[BasicNoteTypes.Note]): V = {
      buffer ++= notes
      value
    }

    def drainTo(f: Seq[BasicNoteTypes.Note] => Unit): V = {
      f(notes)
      value
    }

    def drainTo(eventHandler: EventSender): V = {
      eventHandler !!(notes)
      value
    }

    def drainTo(buffer: mutable.Buffer[BasicNoteTypes.Note], eventSender: EventSender): V = {
      drainTo(buffer)
      drainTo(eventSender)
      value
    }

    def drainWith(f: Seq[Note] => Unit): V = {
      f(notes)
      value
    }
  }

  /**
   * Alias for Annotated[Validation[NonEmptyList[F], S]]
   */
  type AnnotatedValidationNel[F, S] = Annotated[Validation[NonEmptyList[F], S]]

  implicit def ToAnnotatedOps[S](s: S): AnnotatedOps[S] with Object {def self: S} = new AnnotatedOps[S]{
    def self: S = s
  }

  trait AnnotatedOps[S] {
    def self: S
    def annotate(note: Note): Annotated[S] = Annotated(self, Seq(note))
    def annotate(notes: Seq[Note]): Annotated[S] = Annotated(self, notes)

    def annotate[N](ns: Seq[N])(implicit noteMaker: CanBeNote[N]): Annotated[S] = Annotated(self, ns.map(n => noteMaker.toNote(n)))
    def annotate[N](n: N)(implicit noteMaker: CanBeNote[N]): Annotated[S] = Annotated(self, Seq(noteMaker.toNote(n)))

    /**
     * Create a new Annotated with self as the sole note
     */
    def failNotes[F](implicit noteMaker: CanBeNote[S]): Annotated[Validation[NonEmptyList[S], F]] = {
      val validation = Validation.failure[NonEmptyList[S], F](NonEmptyList(self))
      val notesList = Seq(noteMaker.toNote(self))
      Annotated(validation, notesList)
    }

    /**
     * Create a new Annotated with self as a new note appended to the Seq of notes
     */
    def failNotes[F](notes: Seq[Note])(implicit noteMaker: CanBeNote[S]): Annotated[Validation[NonEmptyList[S], F]] = {
      val validation = Validation.failure[NonEmptyList[S], F](NonEmptyList(self))
      val notesList = notes :+ noteMaker.toNote(self)
      Annotated(validation, notesList)
    }

    def successNotes[F]: Annotated[Validation[NonEmptyList[F], S]] = Annotated(Validation.success[NonEmptyList[F], S](self))
    def successNotes[F, N](note: N)(implicit noteMaker: CanBeNote[N]): Annotated[Validation[NonEmptyList[F], S]] = Annotated(Validation.success[NonEmptyList[F], S](self), Seq(noteMaker.toNote(note)))
    def successNotes[F, N](notes: Seq[Note]): Annotated[Validation[NonEmptyList[F], S]] = Annotated(Validation.success[NonEmptyList[F], S](self), notes)
  }

  trait CanBeNote[N]{
    def toNote(t: N): Note
  }

  object CanBeNote {
    implicit def stringCanBeNote: CanBeNote[String] with Object {def toNote(msg: String): Note} = new CanBeNote[String] {
      override def toNote(msg: String): Note = MsgNote(msg)
    }

    implicit def failureResultCanBeNote[N <: FailureResult]: CanBeNote[FailureResult] with Object {def toNote(f: FailureResult): Note} = new CanBeNote[FailureResult] {
      override def toNote(f: FailureResult): Note = MsgNote("FailureResult: " + f.message)
    }
  }

  //Maybe these two should live elsewhere?
  def toNote[N](n: N)(implicit noteMaker: CanBeNote[N], stage: Stage): Note = noteMaker.toNote(n)
  def toNotes[M[_], N](mt: M[N])(implicit noteMaker: CanBeNote[N], traverser: Traverse[M], stage: Stage): M[Note] = traverser.map(mt)(noteMaker.toNote)

  trait NoteBuffer {
    import com.gravity.logging.Logging._
    private val defaultBuffer = new mutable.ArrayBuffer[BasicNoteTypes.Note]

    protected def noteBuffer: mutable.Buffer[BasicNoteTypes.Note] = defaultBuffer

    def enableNoteBuffer: Boolean = true
    def noteLogger: Note => Unit = note => trace(baseRenderPF(noteRenderer)(note).toString)
    def noteRenderer: PartialFunction[Any, String] = { case v => v.toString }

    final def addNotes(notes: => Seq[BasicNoteTypes.Note]): Unit = {
      if (enableNoteBuffer) {
        noteBuffer ++= notes
        notes.foreach(noteLogger)
      }
    }

    final def addNotes[N](notes: => Seq[N])(implicit noteMaker: CanBeNote[N], stage: Stage): Unit = addNotes(notes.map(n => noteMaker.toNote(n): BasicNoteTypes.Note))
    final def addNote(note: => BasicNoteTypes.Note): Unit = addNotes(Seq(note))
    final def addNote[N](n: => N)(implicit noteMaker: CanBeNote[N], stage: Stage): Unit = addNote(noteMaker.toNote(n): BasicNoteTypes.Note)

    final def getNotes: Seq[BasicNoteTypes.Note] = noteBuffer.toSeq
  }
}


object NotEqual_TypeConstraintChecker {
  trait <:!<[A, B]

  implicit def nsub[A, B] : A <:!< B = new <:!<[A, B] {}
  implicit def TypeConstraintViolated[A, B >: A] : A <:!< B = sys.error("Unexpected call")
  implicit def TypesCannotBeEqual[A, B >: A] : A <:!< B = sys.error("Unexpected call")
}

object grvstage {
  import com.gravity.utilities.Tabulator._
  import grvannotation.BasicNoteTypes._
  import grvannotation._

  /**
   * A Stage is way of grouping together a Seq of notes. Defining a stage provides methods for filtering, grouping, rendering, and printing.
   */
  trait Stage {

    //Give us these four
    def label: String
    type StageNote <: Note
    def noteCT: ClassTag[StageNote]
    def makeNote(message: String): StageNote

    //And you get these
    def containsNote(note: Note): Boolean = noteCT.runtimeClass.isInstance(note)  //You might think we could note.isInstanceOf[StageNote] // but we can't. (StageNote seems to refer to Stage#StageNote which matches all stages)

    def filter(notes: Seq[Note]): Seq[StageNote] = notes.filter(note => this.containsNote(note)).map(_.asInstanceOf[StageNote])

    def render(notes: Seq[Note])(implicit renderPF: PartialFunction[Any, String]): RenderedStage = {
      val renderedNotes = filter(notes).map(baseRenderPF(renderPF))
      RenderedStage(label, renderedNotes)
    }

    //helpers
    def classTag[T : ClassTag]: ClassTag[T] = scala.reflect.classTag[T]

    implicit def stageRef: Stage = this

    implicit def stringCanBeNote: grvannotation.CanBeNote[String] with Object {def toNote(msg: String): Note} = new CanBeNote[String] {
      override def toNote(msg: String): Note = makeNote(msg)
    }

    implicit def failureResultCanBeNote[T <: FailureResult]: grvannotation.CanBeNote[T] with Object {def toNote(f: T): Note} = new CanBeNote[T] {
      override def toNote(f: T): Note = makeNote(f.message)
    }

  }

  trait StageWithMeta extends Stage {
    //Give us these two

    /**
     * The type of this Stage's Meta. Should be a case class like
     * case class StageMeta(name: Option[String] = None, context: Option[(URL, Timestamp)])
     */
    type MetaType <: Product

    /**
     * Define a method that wraps your MetaType in
     * @param message A message describing the meta data
     * @param meta The meta data to be stashed in this note
     * @param continuable False indicates that an unrecoverable error is indicated by this note
     * @return a Note instance with meta data suitable for stashing in an Annotated instance
     */
    def makeMetaNote(message: String, meta: MetaType, continuable: Boolean): BasicMetaNote[MetaType] with BasicMessageNote with StageNote

    /**
     * @param notes The notes resulting from a process that returns Annotated
     * @return The BasicMessageMetaNotes for this stage, untyped
     */
    def metaNotes(notes: Seq[Note]): Seq[StageNote with BasicMessageMetaNote[_]] = {                                   //vs BasicMetaNote? Clutters the api.
      notes.filter(note => this.containsNote(note) && note.isInstanceOf[BasicMessageMetaNote[_]]).map(_.asInstanceOf[StageNote with BasicMessageMetaNote[_]])
    }

    /**
     * Finds the meta notes for this stage and casts the meta to the appropriate type, with the message and canContinue as additional Tuple members
     * @param notes The notes resulting from a process that returns Annotated
     * @return A Tuple3 with a properly typed MetaType instance, Message, and CanContinue
     */
    def metaTuple(notes: Seq[Note]): Seq[(MetaType, String, Boolean)] = {
      metaNotes(notes).map(metaNote => (metaNote.meta.asInstanceOf[MetaType], metaNote.message, metaNote.canContinue))
    }

    /**
     * Finds the meta notes for this stage and casts the meta to the appropriate type, without the message nor canContinue
     * @param notes The notes resulting from a process that returns Annotated
     * @return A Seq of properly type MetaType instances
     */
    def meta(notes: Seq[Note]): Seq[MetaType] = {
      metaNotes(notes).map(metaNote => metaNote.meta.asInstanceOf[MetaType])
    }

    /**
     * Find the instances of MetaType that have a value of Some for the field supplied by f
     * @param notes The notes resulting from a process that returns Annotated
     * @param f indicates a field of MetaType to be sought
     * @tparam T The type of the field sought
     * @return A Seq of only those instances of MetaType where the sought field is defined
     */
    def retrieve[T](notes: Seq[Note])(f: MetaType => Option[T]): scala.Seq[T] = {
      meta(notes).flatMap(meta => f(meta))
    }

    def getNotContinuable(notes: Seq[Note]): scala.Seq[StageNote with BasicMessageMetaNote[_]] = {
      metaNotes(notes).filterNot(_.canContinue)
    }

    implicit def stageMetaRef: StageWithMeta = this
  }

  implicit val tabTriples: CanBeTabulated[(String, String, String)] = new CanBeTabulated[(String, String, String)] {
    property("Stage")(_._1)
    property("Note")(_._2)
    property("Meta")(_._3)
  }

  def print(stages: Traversable[RenderedStage]): Unit = {
    val out = stages.flatMap(stage => (stage.label, "", "") +: stage.renderedNotes.map{ case RenderedNote(message, meta) => ("", message, meta)} )
    out.tablePrint()
  }


  def baseRenderPF(renderMeta: PartialFunction[Any, String]): PartialFunction[Note, RenderedNote] = {
    case n: BasicMessageMetaNote[_] => RenderedNote(n.message, grvstrings.renderCaseClassOfOptions(n.meta, withClassnameWrapper = false)(renderMeta)) //n.meta.toString)
    case n: BasicMetaNote[_] => RenderedNote("", n.meta.toString)
    case n: BasicMessageNote => RenderedNote(n.message, "")
  }

  case class RenderedNote(message: String, meta: String) {
    def metaString: String = if(meta == "") "" else s"|| meta: $meta"
    override def toString = s"$message $metaString"
  }
  case class RenderedStage(label: String, renderedNotes: Seq[RenderedNote])
  case class NotesForStage(stageLabel: String, notes: Seq[Note])
  

//  trait StageWithRenderMeta extends StageWithMeta {
//    def renderMeta: PartialFunction[Note, RenderedMetaNote]
//  }

  val idPF: PartialFunction[Any, String] = {
    case x => x.toString
  }

  case class Pipeline(stages: Stage*){

    def group(notes: Seq[Note]): Seq[(String, Seq[Stage#StageNote])] = stages.map(stage => (stage.label, stage.filter(notes)))

    def render(notes: Seq[Note])(renderPF: PartialFunction[Any, String]): Seq[RenderedStage] = {  //perhaps PFs can be extracted from stages and traversed or sequenced?
      stages.map(_.render(notes)(renderPF))
    }                        

    def printPF(notes: Seq[Note])(renderPF: PartialFunction[Any, String] = idPF): Unit = {
      grvstage.print(render(notes)(renderPF))
    }

    def print(notes: Seq[Note]): Unit = {
      grvstage.print(render(notes)(idPF))
    }

    def stagesWithMeta: Seq[StageWithMeta] = stages.collect {
      case st:StageWithMeta => st
    }

    def getNotContinuable(notes: Seq[Note]): Seq[StageWithMeta#StageNote with BasicMessageMetaNote[_]] = {
      stagesWithMeta.flatMap(stage => stage.getNotContinuable(notes))
    }
  }
}



//  trait AnnotatedOps[S]{
//    def self: S
//maybe this takes a stageconfig which contains a canBeNote implementation. therefore the canBeNote can attach the proper stage.
//    def failNotes[F](implicit noteMaker: CanBeNote[S]) = {
//      val validation = Validation.failure[NonEmptyList[S], F](NonEmptyList(self))
//      val notesList = Seq(noteMaker.toNotes(self))
//      Annotated(validation, notesList)
//    }
//    def successNotes[F] = Annotated(Validation.success[NonEmptyList[F], S](self))
//    def successNotes[F](note: InfoNote) = Annotated(Validation.success[NonEmptyList[F], S](self), Seq(note))
//    def successNotes[F](msg: String) = Annotated(Validation.success[NonEmptyList[F], S](self), Seq(new MessageNote(msg)))

//    def annotate(notes: Seq[Note]) = Annotated(self, notes)
//    def annotate(note: Note) = Annotated(self, Seq(note))

//    def annotate[M[_], T](mOfT: M[T])(implicit trav: Traverse[M], noteMaker: CanBeNote[T], stage: Stage) = {
//      val notes = trav.toList(mOfT).map(noteMaker.toNote)
//      Annotated(self, notes)
//    }


//    def annotate = Annotated(self, Seq.empty) //Let's not encourage this

//    implicit class ValidationNelToAnnotatedVNel[F: CanBeNote, S](val nel: Validation[NonEmptyList[F], S]) {
//      def toAnnotated(successNote: Note = NoNote) = {
//        val noteMaker = implicitly[CanBeNote[F]]
//        val noteList = nel.failureList.map(noteMaker.toNotes)
//        Annotated(nel, Seq(noteList:_*))
//      }
//    }
//  }